/**
 * Live2D Desktop Mate - Main Application
 * Enhanced with comprehensive error handling, logging, and fallbacks
 */

// Configuration
const CONFIG = {
    MODEL_PATH: 'web/models/Hiyori/Hiyori.model3.json',
    WS_URL: window.location.origin,
    SOCKET_OPTIONS: {
        transports: ['websocket', 'polling'],
        reconnectionAttempts: 5,
        timeout: 10000
    },
    LOGGING: {
        enabled: true,
        maxEntries: 100,
        levels: ['error', 'warn', 'info', 'debug']
    }
};

// Global state
const AppState = {
    socket: null,
    live2dRenderer: null,
    character2d: null,
    isModelLoaded: false,
    retryCount: 0,
    maxRetries: 3
};

/**
 * Enhanced Logger with UI output
 */
class Logger {
    constructor() {
        this.logs = [];
        this.container = null;
    }

    init() {
        this.container = document.getElementById('logContainer');
        if (!this.container) {
            console.warn('[Logger] Log container not found');
        }
    }

    log(level, message, data = null) {
        if (!CONFIG.LOGGING.enabled) return;

        const timestamp = new Date().toISOString();
        const logEntry = { level, message, data, timestamp };
        
        this.logs.push(logEntry);
        
        // Limit log entries
        if (this.logs.length > CONFIG.LOGGING.maxEntries) {
            this.logs.shift();
        }

        // Console output with styling
        const styles = {
            error: 'color: #f44336; font-weight: bold;',
            warn: 'color: #ff9800; font-weight: bold;',
            info: 'color: #2196F3;',
            debug: 'color: #9E9E9E;'
        };

        console.log(`%c[${level.toUpperCase()}] ${message}`, styles[level] || '', data || '');

        // UI output
        this.updateUI(logEntry);
    }

    updateUI(logEntry) {
        if (!this.container) return;

        const logElement = document.createElement('div');
        logElement.className = `log-entry log-${logEntry.level}`;
        
        const time = new Date(logEntry.timestamp).toLocaleTimeString();
        logElement.innerHTML = `
            <span class="log-time">${time}</span>
            <span class="log-level">[${logEntry.level.toUpperCase()}]</span>
            <span class="log-message">${logEntry.message}</span>
        `;

        this.container.appendChild(logElement);
        this.container.scrollTop = this.container.scrollHeight;
    }

    clear() {
        this.logs = [];
        if (this.container) {
            this.container.innerHTML = '';
        }
    }

    error(message, data) { this.log('error', message, data); }
    warn(message, data) { this.log('warn', message, data); }
    info(message, data) { this.log('info', message, data); }
    debug(message, data) { this.log('debug', message, data); }
}

const logger = new Logger();

/**
 * Initialize Socket.IO connection with fallbacks
 */
function initSocket() {
    logger.info('Initializing socket connection...', { url: CONFIG.WS_URL });

    try {
        AppState.socket = io(CONFIG.WS_URL, CONFIG.SOCKET_OPTIONS);
    } catch (error) {
        logger.error('Socket initialization failed', error);
        showError('Failed to initialize socket connection');
        return;
    }

    AppState.socket.on('connect', () => {
        logger.info('✓ Server connected');
        updateConnectionStatus(true);
    });

    AppState.socket.on('disconnect', () => {
        logger.warn('✗ Server disconnected');
        updateConnectionStatus(false);
    });

    AppState.socket.on('connect_error', (error) => {
        logger.error('Socket connection error', error);
    });

    AppState.socket.on('model_state', (data) => {
        logger.debug('Model state received', data);
        applyModelState(data);
    });

    AppState.socket.on('parameter_update', (data) => {
        logger.debug('Parameter update', data);
        updateParameter(data.id, data.value);
    });

    AppState.socket.on('expression_update', (data) => {
        logger.debug('Expression update', data);
        setExpression(data.expression, data.active);
    });

    AppState.socket.on('motion_start', (data) => {
        logger.info('Motion started', data);
    });

    AppState.socket.on('clients_count_response', (data) => {
        updateClientCount(data.count);
    });
}

/**
 * Update connection status in UI
 */
function updateConnectionStatus(isConnected) {
    const statusElement = document.getElementById('connectionStatus');
    if (!statusElement) return;

    if (isConnected) {
        statusElement.innerHTML = '✅ Server connected';
        statusElement.style.color = '#4CAF50';
    } else {
        statusElement.innerHTML = '❌ Server disconnected';
        statusElement.style.color = '#f44336';
    }
}

/**
 * Update client count in UI
 */
function updateClientCount(count) {
    const countElement = document.getElementById('clientCount');
    if (countElement) {
        countElement.textContent = count;
    }
}

/**
 * Request client count from server
 */
function requestClientCount() {
    if (AppState.socket && AppState.socket.connected) {
        AppState.socket.emit('get_clients_count', {});
    }
}

/**
 * Apply model state from server
 */
function applyModelState(state) {
    if (!state) {
        logger.warn('Empty model state received');
        return;
    }

    logger.debug('Applying model state', state);

    try {
        if (state.parameters) {
            Object.entries(state.parameters).forEach(([param, value]) => {
                updateParameter(param, value);
            });
        }

        if (state.expressions) {
            Object.entries(state.expressions).forEach(([expr, active]) => {
                setExpression(expr, active);
            });
        }
    } catch (error) {
        logger.error('Failed to apply model state', error);
    }
}

/**
 * Update parameter value with fallbacks
 */
function updateParameter(paramId, value) {
    try {
        if (AppState.character2d && typeof AppState.character2d.setParameter === 'function') {
            AppState.character2d.setParameter(paramId, value);
            // Reduced logging - only log on first call or errors
        } else if (AppState.live2dRenderer && typeof AppState.live2dRenderer.setParameter === 'function') {
            AppState.live2dRenderer.setParameter(paramId, value);
            // Reduced logging - only log on first call or errors
        } else {
            logger.warn('No renderer available to update parameter', { paramId, value });
        }
    } catch (error) {
        logger.error('Failed to update parameter', { paramId, value, error });
    }
}

/**
 * Set expression state with fallbacks
 */
function setExpression(expression, active) {
    try {
        if (AppState.character2d && typeof AppState.character2d.setExpression === 'function') {
            if (active) {
                AppState.character2d.setExpression(expression);
                logger.info(`Expression ${expression}: On`);
            } else {
                logger.info(`Expression ${expression}: Off`);
            }
        } else if (AppState.live2dRenderer && typeof AppState.live2dRenderer.setExpression === 'function') {
            AppState.live2dRenderer.setExpression(expression);
            logger.info(`Expression (fallback) ${expression}: On`);
        } else {
            logger.warn('No renderer available to set expression', { expression, active });
        }
    } catch (error) {
        logger.error('Failed to set expression', { expression, active, error });
    }
}

/**
 * Initialize UI controls with error handling
 */
function initControls() {
    logger.info('Initializing UI controls...');

    try {
        // Parameter sliders
        const sliders = {
            'angleX': 'ParamAngleX',
            'angleY': 'ParamAngleY',
            'eyeOpen': 'ParamEyeLOpen',
            'mouthOpen': 'ParamMouthOpenY'
        };

        Object.entries(sliders).forEach(([sliderId, paramId]) => {
            const slider = document.getElementById(sliderId);
            const valueSpan = document.getElementById(sliderId + 'Value');

            if (!slider || !valueSpan) {
                logger.warn(`Slider or value span not found: ${sliderId}`);
                return;
            }

            slider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                valueSpan.textContent = value.toFixed(2);

                // Send to server
                if (AppState.socket && AppState.socket.connected) {
                    AppState.socket.emit('set_parameter', { id: paramId, value });
                }

                // Update locally
                updateParameter(paramId, value);
            });
        });

        // Expression buttons
        document.querySelectorAll('.expr-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                handleExpressionClick(this);
            });
        });

        // Motion buttons
        document.querySelectorAll('.motion-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                handleMotionClick(this);
            });
        });

        // Clear log button
        const clearLogBtn = document.getElementById('clearLogBtn');
        if (clearLogBtn) {
            clearLogBtn.addEventListener('click', () => logger.clear());
        }

        // Retry button
        const retryBtn = document.getElementById('retryBtn');
        if (retryBtn) {
            retryBtn.addEventListener('click', () => retryLoadModel());
        }

        logger.info('UI controls initialized successfully');
    } catch (error) {
        logger.error('Failed to initialize controls', error);
    }
}

/**
 * Handle expression button click
 */
function handleExpressionClick(button) {
    try {
        const expr = button.dataset.expr;
        const isActive = !button.classList.contains('active');

        button.classList.toggle('active');

        // Send to server
        if (AppState.socket && AppState.socket.connected) {
            AppState.socket.emit('set_expression', { expression: expr, active: isActive });
        }

        // Set locally
        setExpression(expr, isActive);
    } catch (error) {
        logger.error('Failed to handle expression click', error);
    }
}

/**
 * Handle motion button click
 */
function handleMotionClick(button) {
    try {
        const group = button.dataset.group;

        // Send to server
        if (AppState.socket && AppState.socket.connected) {
            AppState.socket.emit('play_motion', { group, index: 0, priority: 3 });
        }

        // Play locally
        if (AppState.character2d && typeof AppState.character2d.playMotion === 'function') {
            AppState.character2d.playMotion(group, 0, 3);
            logger.info(`Playing motion: ${group}`);
        } else {
            logger.warn('No renderer available to play motion', { group });
        }
    } catch (error) {
        logger.error('Failed to handle motion click', error);
    }
}

/**
 * Load Live2D model with comprehensive error handling and fallbacks
 */
async function loadModel() {
    logger.info('Loading Live2D model...', { path: CONFIG.MODEL_PATH });
    showLoading(true);

    try {
        // Check if Live2DCubismCore is loaded
        if (typeof Live2DCubismCore === 'undefined') {
            throw new Error('Live2D Cubism Core library not loaded');
        }
        logger.info('✓ Live2D Cubism Core loaded');

        // Get canvas
        const canvas = document.getElementById('live2dCanvas');
        if (!canvas) {
            throw new Error('Canvas element not found');
        }
        logger.info('✓ Canvas element found');

        // Check for Live2DDesktopMate (from Live2DWrapper.js)
        if (typeof Live2DDesktopMate !== 'undefined') {
            logger.info('Using Live2DDesktopMate renderer');
            AppState.character2d = new Live2DDesktopMate({});
            globalThis.character2d = AppState.character2d;

            // Load model (pass the .model3.json path, not .moc3)
            const modelPath = CONFIG.MODEL_PATH;
            logger.info('Loading model file...', { path: modelPath });
            
            const success = await AppState.character2d.loadModel(modelPath);
            
            if (success) {
                AppState.character2d.startAnimation();
                AppState.isModelLoaded = true;
                logger.info('✓ Model loaded and animation started successfully');
                showLoading(false);
                AppState.retryCount = 0;
            } else {
                throw new Error('Failed to load model (loadModel returned false)');
            }
        } else {
            throw new Error('Live2DDesktopMate class not available');
        }

    } catch (error) {
        logger.error('Failed to load model', error);
        showError(error.message);
        showLoading(false);
        
        // Retry logic
        if (AppState.retryCount < AppState.maxRetries) {
            AppState.retryCount++;
            logger.info(`Retrying... (${AppState.retryCount}/${AppState.maxRetries})`);
            setTimeout(() => loadModel(), 2000);
        } else {
            logger.error('Max retry attempts reached');
        }
    }
}

/**
 * Retry loading the model
 */
function retryLoadModel() {
    logger.info('Manual retry triggered');
    AppState.retryCount = 0;
    hideError();
    loadModel();
}

/**
 * Show/hide loading overlay
 */
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.style.display = show ? 'flex' : 'none';
    }
}

/**
 * Show error overlay
 */
function showError(message) {
    const overlay = document.getElementById('errorOverlay');
    const messageElement = document.getElementById('errorMessage');
    
    if (overlay && messageElement) {
        messageElement.textContent = message;
        overlay.style.display = 'flex';
    }
}

/**
 * Hide error overlay
 */
function hideError() {
    const overlay = document.getElementById('errorOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

/**
 * Initialize the application
 */
async function initApp() {
    logger.info('=== Live2D Desktop Mate Starting ===');
    logger.init();

    try {
        // Check browser compatibility
        if (!window.WebGLRenderingContext) {
            throw new Error('WebGL not supported in this browser');
        }
        logger.info('✓ WebGL supported');

        // Initialize socket
        initSocket();

        // Initialize controls
        initControls();

        // Load model
        await loadModel();

        // Set up periodic updates
        setInterval(requestClientCount, 10000);

        logger.info('=== Application initialized successfully ===');
    } catch (error) {
        logger.error('Application initialization failed', error);
        showError('Failed to initialize application: ' + error.message);
    }
}

/**
 * Handle page unload
 */
window.addEventListener('beforeunload', () => {
    logger.info('Page unloading, cleaning up...');
    
    if (AppState.socket) {
        AppState.socket.disconnect();
    }
    
    if (AppState.character2d && typeof AppState.character2d.destroy === 'function') {
        AppState.character2d.destroy();
    }
});

/**
 * Start the application when page loads
 */
window.addEventListener('load', initApp);

/**
 * Handle errors globally
 */
window.addEventListener('error', (event) => {
    logger.error('Global error caught', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
    });
});

/**
 * Handle unhandled promise rejections
 */
window.addEventListener('unhandledrejection', (event) => {
    logger.error('Unhandled promise rejection', {
        reason: event.reason
    });
});
